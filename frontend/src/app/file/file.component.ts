import { Component, OnInit } from '@angular/core';
import {ApiService} from '../shared/api.service';
import {AuthService} from '../shared/auth.service';
import {ActivatedRoute, Router} from '@angular/router';

@Component({
  selector: 'app-file',
  templateUrl: './file.component.html',
  styleUrls: ['./file.component.scss']
})
export class FileComponent implements OnInit {
    pageContent: {
        pk: 0;
        content: '';
        short_content: '';
        title: '';
        user: 0;
        questions: [];
    };
  title = 'ASSEMBLY  LANGUAGE  BASICS';
  content = 'Machine Language of a Computing System (CS) –  the set of the machine instructions to which the processor directly reacts. These are represented as bit strings with predefined semantics. \n' +
      '\n' +
      'Assembly Language – a programming language in which the basic instructions set corresponds with the machine operations and which data structures are the machine primary structures. This is a symbolic language. Symbols -  Mnemonics + labels.\n' +
      '\t\n' +
      'The basic elements with which an assembler works with are:\n' +
      '\n' +
      '* labels – user-defined names for pointing to data or memory areas.  \n' +
      '\t\n' +
      '* instructions - mnemonics which suggests the underlying action. The assembler generates the bytes that codifies the corresponding instruction.\n' +
      '\n' +
      '* directives - indications given to the assembler for correctly generating the corresponding bytes. Ex: relationships between the object modules, segment definitions, conditional assembling, data definition directives.\n' +
      '\n' +
      '* location counter – an integer number managed by the assembler for every separate memory segment. At any given moment, the value of the location counter is the number of the generated bytes correspondingly with the instructions and the directives already met in that segment  (the current offset inside that segment). The programmer can use this value (read-only access!) by specifying in the source code the \'$\' symbol. \n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '3.1. SOURCE  LINE  FORMAT\n' +
      '\n' +
      'In the 8086 assembly language the source line format is:\n' +
      '\n' +
      '\t\t[label] [mnemonic] [operands] [;comment]\n' +
      '\n' +
      'The allowed characters for a label are A - Z  a - z   _   @   $   ?   0 - 9\n' +
      '\n' +
      '1). Code labels, present at the level of instructions sequences (code segments) for defining the destinations of the control transfer during a program execution. \n' +
      '\n' +
      '2). Data labels, which provide symbolic identification for some memory locations, from a semantic point of view being similar with the variable concept from the other programming languages. \n' +
      '\n' +
      'The value associated with a label in assembly language is an integer number representing the address of the instruction or directive following that label.  \n' +
      '\n' +
      'The difference between accessing the address and the contents of a named memory location is made depending on the context of usage. Example:\n' +
      ' \n' +
      '\tlea ax, v\t; loads in the ax register the address of the v variable\n' +
      '\tmov ax, v\t; loads in the ax  register the contents of the v variable \n' +
      '\n' +
      'There are 2 mnemonics cathegories: instructions names and directives names. Directives guide the assembler. They specify the particular way in which the assembler will generate the object code. Instructions are actions that guide the processor. \n' +
      '\n' +
      'Operands are parameters which define the values to be processed by the instructions or directives. They can be registers, constants, labels, expressions, keywords or other symbols. Their semantics  depends on the mnemonic of the associated instruction or directive. \n' +
      '\t3.2. EXPRESSIONS\n' +
      '\n' +
      'expression  - operands + operators. Operators indicate how to combine the operands for building an expression. Expressions are evaluated at assembly time (their values are computable at assembly time, except the operands representing registers contents and can be evaluated only at run time). \n' +
      '\n' +
      '\t3.2.1. Addressing modes\n' +
      '\n' +
      'Instructions operands may be specified in 3 different ways, called addressing modes. \n' +
      '\n' +
      'The 3 operand types are: immediate operands, register operands and memory operands. Their values are computed at assembly time for the immediate operands, at loading time for memory operands in direct addressing mode and at run time for the registers operands and for indirectly accessed memory operands. \n' +
      '\n' +
      '\t3.2.1.1.  Immediate operands\n' +
      '\n' +
      'Immediate operands are constant numeric data computable at assembly time. \n' +
      '\n' +
      'The offsets of data labels and code labels are values computable at assembly time and they remain constant during the whole program’s run-time. \n' +
      '\n' +
      '\t\tlea ax, v\t; transfer in the AX register the offset of the v variable\n' +
      '\n' +
      'will be evaluated at assembly time as (for example): \n' +
      '\n' +
      '\t\tlea ax, 0008 \t; 8 bytes „distance” relative to the beginning of the data segment\n' +
      '\n' +
      'In a similar way,       jmp  et     will be evaluated as\t   jmp [0004]↓     meaning “jump 4 bytes lower from the current position”.\n' +
      '\n' +
      '\n' +
      '\t3.2.1.2.  Register operands\n' +
      '\n' +
      'Direct addressing  -  mov ax,bx \n' +
      'Indirect addressing – used for pointing to memory locations - mov ax,[bx] \n' +
      ' \t(offset = [ BX | BP ] + [ SI | DI ] + [ constant ])\n' +
      '\n' +
      '\t3.2.1.3.  Memory addressing operands\n' +
      '\n' +
      'There are 2 types of memory operands: direct addressing operands and indirect addressing operands..\n' +
      '\n' +
      'The direct addressing operand is a constant or a symbol representing the address (segment and offset) of an instruction or some data. These operands may be labels (for ex: jmp et), procedures names (for ex: call proc1) or the value of the location counter (for ex: b db $-a). \n' +
      '\n' +
      'The offset of a direct addressing operand is computed at assembly time. The address of every  operand relative to the executable program structure (establishing the segments to which the computed offsets are relative to) is computed at linking time. The actual physical address is computed at   loading time.\n' +
      '\n';
  questions = [
      {
          title: 'What provides symbolic identification for some memory locations?',
          answers: ['Data labels', 'Code labels', 'Labels'],
      },
      {
          title: 'Which are the 2 mnemonics categories?',
          answers: ['instructions names and directives names', 'Directives guide', 'Registers, constants']

      },
      {
          title: 'What is the offset',
          answers: ['a direct addressing operand', 'executable program structure', 'actual physical address ']
      },
  ];
  constructor(
      private apiService: ApiService,
      private authService: AuthService,
      private router: Router,
      private route: ActivatedRoute,
  ) { }

  ngOnInit() {
      if (!this.authService.isUserAuthenticated()) {
          this.router.navigate(['/']);
      }
      const userDocumentId = this.route.snapshot.paramMap.get('id');
      console.log(userDocumentId);
      this.apiService.getDocumentWithIdAndQuestions(userDocumentId.toString()).subscribe(
          (response: any) => {
                this.title = response.title;
                this.content = response.content;
                this.questions = [...response.questions];
                console.log(response);
          },
      error1 => {
          console.log(error1);
      }
      );
  }

}
